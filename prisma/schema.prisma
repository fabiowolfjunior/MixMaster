generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Product {
  id                 String   @id @default(uuid())
  name               String
  barcode            String?
  category           String?
  price              Float
  isComposite        Boolean  @default(false)
  image              String? // Base64 or URL
  
  // Relations
  resaleIngredientId String?
  resaleIngredient   Ingredient? @relation("ResaleIngredient", fields: [resaleIngredientId], references: [id])
  resaleQuantity     Float?   @default(1)
  
  recipeItems        RecipeItem[]
  saleItems          SaleItem[]
  
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Advanced Features
  pricingTiers       PricingTier[]
  batches            Batch[]
}

model Ingredient {
  id               String   @id @default(uuid())
  name             String
  barcode          String?
  supplierId       String?
  costPerPackage   Float
  volumePerPackage Float
  unit             String // 'ml', 'l', 'g', 'kg', 'un'
  currentStock     Float
  minStock         Float
  costPerUnit      Float
  
  // Relations
  recipeItems      RecipeItem[]
  products         Product[]     @relation("ResaleIngredient") // Reverse relation for resaleIngredientId (manual handle via ID usually easier in simple app but relations are good)
  
  purchaseItems    PurchaseItem[]

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model RecipeItem {
  id           String     @id @default(uuid())
  productId    String
  product      Product    @relation(fields: [productId], references: [id], onDelete: Cascade)
  ingredientId String
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id])
  quantity     Float

  @@unique([productId, ingredientId])
}

model Supplier {
  id             String   @id @default(uuid())
  name           String
  legalName      String?
  type           String // 'PF' | 'PJ'
  document       String
  roles          String? // JSON string of roles array
  
  // Contact
  address        String?
  phone          String?
  email          String?
  
  // Additional
  unitValue      Float?
  
  purchases      PurchaseRecord[]
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model PurchaseRecord {
  id          String   @id @default(uuid())
  date        DateTime
  totalValue  Float
  
  supplierId  String
  supplier    Supplier @relation(fields: [supplierId], references: [id])
  
  items       PurchaseItem[]
  
  createdAt   DateTime @default(now())
}

model PurchaseItem {
  id             String         @id @default(uuid())
  purchaseId     String
  purchase       PurchaseRecord @relation(fields: [purchaseId], references: [id], onDelete: Cascade)
  ingredientId   String
  ingredient     Ingredient     @relation(fields: [ingredientId], references: [id])
  
  quantity       Float
  cost           Float 
}

model Sale {
  id            String   @id @default(uuid())
  date          DateTime @default(now())
  total         Float
  paymentMethod String // 'credit', 'debit', 'cash', 'pix'
  
  customerId    String?
  customerName  String?
  
  items         SaleItem[]
  
  fiscalJson    String? // Store simulated fiscal data as JSON string
  
  // Relations
  routeItems    RouteItem[]
}

model SaleItem {
  id          String   @id @default(uuid())
  saleId      String
  sale        Sale     @relation(fields: [saleId], references: [id], onDelete: Cascade)
  
  productId   String
  product     Product  @relation(fields: [productId], references: [id])
  productName String
  
  quantity    Float
  priceAtSale Float
  costAtSale  Float
}

// Financials
model Expense {
  id          String   @id @default(uuid())
  description String
  amount      Float
  date        DateTime
  category    String
}

model LossRecord {
  id          String   @id @default(uuid())
  date        DateTime
  description String
  value       Float
  quantity    Float?
}

model Settings {
  id         String @id @default("default")
  fixedCosts Float  @default(0)
  pixKey     String?
  storeName  String?
  logo       String? // Base64
  company    String? // JSON string for CompanySettings
}

model PricingTier {
  id          String  @id @default(uuid())
  productId   String
  product     Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  label       String  // e.g., "Atacado", "Caixa Fechada"
  minQuantity Int     // e.g., 12
  unitPrice   Float   // e.g., 4.50 (instead of normal 5.00)
}

model Batch {
  id             String    @id @default(uuid())
  productId      String
  product        Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  code           String    // Lote 123
  expirationDate DateTime
  initialStock   Float
  currentStock   Float
  createdAt      DateTime  @default(now())
}

// Logistics Models
model Driver {
  id        String   @id @default(uuid())
  name      String
  phone     String?
  license   String?  // CNH
  active    Boolean  @default(true)
  routes    Route[]
  createdAt DateTime @default(now())
}

model Route {
  id          String      @id @default(uuid())
  date        DateTime    @default(now())
  status      String      // 'pending', 'started', 'completed'
  driverId    String?
  driver      Driver?     @relation(fields: [driverId], references: [id])
  items       RouteItem[]
  
  departureTime DateTime?
  arrivalTime   DateTime?
  
  updatedAt   DateTime    @updatedAt
}

model RouteItem {
  id        String  @id @default(uuid())
  routeId   String
  route     Route   @relation(fields: [routeId], references: [id], onDelete: Cascade)
  
  saleId    String
  sale      Sale    @relation(fields: [saleId], references: [id])
  
  status    String  // 'pending', 'delivered', 'failed'
  order     Int     // Sequence in route
}
